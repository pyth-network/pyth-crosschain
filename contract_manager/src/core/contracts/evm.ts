import {
  getContract,
  type PublicClient,
  keccak256,
  toHex,
  hexToString,
  encodeFunctionData,
} from "viem";
import { PriceFeedContract, PrivateKey, Storable } from "../base";
import { Chain, EvmChain } from "../chains";
import { DataSource } from "@pythnetwork/xc-admin-common";
import { WormholeContract } from "./wormhole";
import { TokenQty } from "../token";
import {
  EXECUTOR_ABI,
  EXTENDED_ENTROPY_ABI,
  EXTENDED_PYTH_ABI,
  WORMHOLE_ABI,
  PULSE_UPGRADEABLE_ABI,
  LAZER_ABI,
} from "./evm_abis";

/**
 * Returns the keccak256 digest of the contract bytecode at the given address after replacing
 * any occurrences of the contract addr in the bytecode with 0.The bytecode stores the deployment
 * address as an immutable variable. This behavior is inherited from OpenZeppelin's implementation
 * of UUPSUpgradeable contract. You can read more about verification with immutable variables here:
 * https://docs.sourcify.dev/docs/immutables/
 * This function can be used to verify that the contract code is the same on all chains and matches
 * with the deployedCode property generated by truffle builds
 */
export async function getCodeDigestWithoutAddress(
  client: PublicClient,
  address: string,
): Promise<string> {
  const code = await client.getCode({ address: address as `0x${string}` });
  const strippedCode = code!.replaceAll(
    address.toLowerCase().replace("0x", ""),
    "0000000000000000000000000000000000000000",
  );
  return keccak256(strippedCode as `0x${string}`);
}

export class EvmWormholeContract extends WormholeContract {
  static type = "EvmWormholeContract";

  getId(): string {
    return `${this.chain.getId()}_${this.address}`;
  }

  getChain(): EvmChain {
    return this.chain;
  }

  getType(): string {
    return EvmWormholeContract.type;
  }

  async getVersion(): Promise<string> {
    const contract = this.getContract();
    return contract.read.version([]) as Promise<string>;
  }

  static fromJson(
    chain: Chain,
    parsed: { type: string; address: string },
  ): EvmWormholeContract {
    if (parsed.type !== EvmWormholeContract.type)
      throw new Error("Invalid type");
    if (!(chain instanceof EvmChain))
      throw new Error(`Wrong chain type ${chain}`);
    return new EvmWormholeContract(chain, parsed.address);
  }

  constructor(
    public chain: EvmChain,
    public address: string,
  ) {
    super();
  }
  getContract() {
    const client = this.chain.getPublicClient();
    return getContract({
      address: this.address as `0x${string}`,
      abi: WORMHOLE_ABI,
      client,
    });
  }

  async getCurrentGuardianSetIndex(): Promise<number> {
    const wormholeContract = this.getContract();
    return Number(await wormholeContract.read.getCurrentGuardianSetIndex([]));
  }

  async getChainId(): Promise<number> {
    const wormholeContract = this.getContract();
    return Number(await wormholeContract.read.chainId([]));
  }

  /**
   * Returns an array of guardian addresses used for VAA verification in this contract
   */
  async getGuardianSet(): Promise<string[]> {
    const wormholeContract = this.getContract();
    const currentIndex = await this.getCurrentGuardianSetIndex();
    const result = (await wormholeContract.read.getGuardianSet([
      currentIndex,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ])) as any[];
    return result[0];
  }

  async upgradeGuardianSets(senderPrivateKey: PrivateKey, vaa: Buffer) {
    const walletClient = this.chain.getWalletClient(senderPrivateKey);
    const publicClient = this.chain.getPublicClient();
    const contract = getContract({
      address: this.address as `0x${string}`,
      abi: WORMHOLE_ABI,
      client: { public: publicClient, wallet: walletClient },
    });

    const hash = await contract.write.submitNewGuardianSet(
      [("0x" + vaa.toString("hex")) as `0x${string}`],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      {} as any,
    );

    const receipt = await publicClient.waitForTransactionReceipt({ hash });

    return { id: hash, info: receipt };
  }

  toJson() {
    return {
      chain: this.chain.getId(),
      address: this.address,
      type: EvmWormholeContract.type,
    };
  }
}

interface EntropyProviderInfo {
  feeInWei: string;
  accruedFeesInWei: string;
  originalCommitment: string;
  originalCommitmentSequenceNumber: string;
  commitmentMetadata: string;
  uri: string;
  endSequenceNumber: string;
  sequenceNumber: string;
  currentCommitment: string;
  currentCommitmentSequenceNumber: string;
  feeManager: string;
}

interface EntropyRequest {
  provider: string;
  sequenceNumber: string;
  numHashes: string;
  commitment: string;
  blockNumber: string;
  requester: string;
  useBlockhash: boolean;
  isRequestWithCallback: boolean;
}

export const ENTROPY_DEFAULT_PROVIDER = {
  mainnet: "0x52DeaA1c84233F7bb8C8A45baeDE41091c616506",
  testnet: "0x6CC14824Ea2918f5De5C2f75A9Da968ad4BD6344",
};
export const ENTROPY_DEFAULT_KEEPER = {
  mainnet: "0xbcab779fca45290288c35f5e231c37f9fa87b130",
  testnet: "0xa5A68ed167431Afe739846A22597786ba2da85df",
};

export class EvmEntropyContract extends Storable {
  static type = "EvmEntropyContract";

  constructor(
    public chain: EvmChain,
    public address: string,
  ) {
    super();
  }

  getId(): string {
    return `${this.chain.getId()}_${this.address}`;
  }

  getChain(): EvmChain {
    return this.chain;
  }

  getType(): string {
    return EvmEntropyContract.type;
  }

  async getVersion(): Promise<string> {
    const contract = this.getContract();
    return contract.read.version([]) as Promise<string>;
  }

  static fromJson(
    chain: Chain,
    parsed: { type: string; address: string },
  ): EvmEntropyContract {
    if (parsed.type !== EvmEntropyContract.type)
      throw new Error("Invalid type");
    if (!(chain instanceof EvmChain))
      throw new Error(`Wrong chain type ${chain}`);
    return new EvmEntropyContract(chain, parsed.address);
  }

  // Generates a payload for the newAdmin to call acceptAdmin on the entropy contracts
  generateAcceptAdminPayload(newAdmin: string): Buffer {
    const data = encodeFunctionData({
      abi: EXTENDED_ENTROPY_ABI,
      functionName: "acceptAdmin",
      args: [],
    });
    return this.chain.generateExecutorPayload(newAdmin, this.address, data);
  }

  // Generates a payload for newOwner to call acceptOwnership on the entropy contracts
  generateAcceptOwnershipPayload(newOwner: string): Buffer {
    const data = encodeFunctionData({
      abi: EXTENDED_ENTROPY_ABI,
      functionName: "acceptOwnership",
      args: [],
    });
    return this.chain.generateExecutorPayload(newOwner, this.address, data);
  }

  async generateUpgradeEntropyContractPayload(
    newImplementation: string,
  ): Promise<Buffer> {
    const data = encodeFunctionData({
      abi: EXTENDED_ENTROPY_ABI,
      functionName: "upgradeTo",
      args: [newImplementation],
    });
    return this.chain.generateExecutorPayload(
      await this.getOwner(),
      this.address,
      data,
    );
  }

  // Generates a payload to upgrade the executor contract, the owner of entropy contracts
  async generateUpgradeExecutorContractsPayload(
    newImplementation: string,
  ): Promise<Buffer> {
    const executorAddr = await this.getOwner();
    const data = encodeFunctionData({
      abi: EXECUTOR_ABI,
      functionName: "upgradeTo",
      args: [newImplementation],
    });
    return this.chain.generateExecutorPayload(executorAddr, executorAddr, data);
  }

  async getOwner(): Promise<string> {
    const contract = this.getContract();
    return contract.read.owner([]) as Promise<string>;
  }

  async getExecutorContract(): Promise<EvmExecutorContract> {
    const owner = await this.getOwner();
    return new EvmExecutorContract(this.chain, owner);
  }

  async getPendingOwner(): Promise<string> {
    const contract = this.getContract();
    return contract.read.pendingOwner([]) as Promise<string>;
  }

  toJson() {
    return {
      chain: this.chain.getId(),
      address: this.address,
      type: EvmEntropyContract.type,
    };
  }

  getContract() {
    const client = this.chain.getPublicClient();
    return getContract({
      address: this.address as `0x${string}`,
      abi: EXTENDED_ENTROPY_ABI,
      client,
    });
  }

  async getDefaultProvider(): Promise<string> {
    const contract = this.getContract();
    return (await contract.read.getDefaultProvider([])) as Promise<string>;
  }

  async getProviderInfo(address: string): Promise<EntropyProviderInfo> {
    const contract = this.getContract();
    const info = (await contract.read.getProviderInfo([
      address,
    ])) as EntropyProviderInfo;
    return {
      ...info,
      uri: hexToString(info.uri as `0x${string}`),
    };
  }

  /**
   * Returns the request for the given provider and sequence number
   * This will return a EntropyRequest object with sequenceNumber "0" if the request does not exist
   * @param provider The entropy provider address
   * @param sequenceNumber The sequence number of the request for the provider
   */
  async getRequest(
    provider: string,
    sequenceNumber: number,
  ): Promise<EntropyRequest> {
    const contract = this.getContract();
    return contract.read.getRequest([
      provider,
      sequenceNumber,
    ]) as Promise<EntropyRequest>;
  }

  /**
   * Returns the user random number for the request with the given provider and sequence number
   * This method assumes the request was made with a callback option and fetches the user random number
   * by finding the `RequestedWithCallback` log. The block number at which the request was made is required
   * to find the log.
   * @param provider The entropy provider address
   * @param sequenceNumber The sequence number of the request for the provider
   * @param block The block number at which the request was made, you can find this using the `getRequest` method
   */
  async getUserRandomNumber(
    provider: string,
    sequenceNumber: number,
    block: number,
  ): Promise<string> {
    const publicClient = this.chain.getPublicClient();
    const logs = await publicClient.getContractEvents({
      address: this.address as `0x${string}`,
      abi: EXTENDED_ENTROPY_ABI,
      eventName: "RequestedWithCallback",
      fromBlock: BigInt(block),
      toBlock: BigInt(block),
      args: {
        provider: provider as `0x${string}`,
        sequenceNumber: BigInt(sequenceNumber),
      },
    });
    if (logs.length === 0) {
      throw new Error("No RequestedWithCallback event found");
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (logs[0] as any).args.userRandomNumber;
  }

  /**
   * Submits a transaction to the entropy contract to reveal the random number and call the callback function
   * @param userRandomNumber The random number generated by the user, you can find this using the `getUserRandomNumber` method
   * @param providerRevelation The random number generated by the provider, you can find this via the provider server
   * @param provider The entropy provider address
   * @param sequenceNumber The sequence number of the request for the provider
   * @param senderPrivateKey The private key to use for submitting the transaction on-chain
   */
  async revealWithCallback(
    userRandomNumber: string,
    providerRevelation: string,
    provider: string,
    sequenceNumber: number,
    senderPrivateKey: PrivateKey,
  ) {
    const walletClient = this.chain.getWalletClient(senderPrivateKey);
    const contract = getContract({
      address: this.address as `0x${string}`,
      abi: EXTENDED_ENTROPY_ABI,
      client: { public: this.chain.getPublicClient(), wallet: walletClient },
    });

    const hash = await contract.write.revealWithCallback(
      [
        provider as `0x${string}`,
        BigInt(sequenceNumber),
        userRandomNumber as `0x${string}`,
        providerRevelation as `0x${string}`,
      ],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      {} as any,
    );

    const publicClient = this.chain.getPublicClient();
    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    return receipt;
  }

  generateUserRandomNumber() {
    const randomBytes = new Uint8Array(32);
    crypto.getRandomValues(randomBytes);
    return toHex(randomBytes);
  }

  async getFee(provider: string): Promise<number> {
    const contract = this.getContract();
    return Number(await contract.read.getFee([provider]));
  }

  async requestRandomness(
    userRandomNumber: string,
    provider: string,
    senderPrivateKey: PrivateKey,
    withCallback?: boolean,
  ) {
    const userCommitment = keccak256(userRandomNumber as `0x${string}`);
    const walletClient = this.chain.getWalletClient(senderPrivateKey);
    const publicClient = this.chain.getPublicClient();

    const readContract = getContract({
      address: this.address as `0x${string}`,
      abi: EXTENDED_ENTROPY_ABI,
      client: publicClient,
    });

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const fee = (await readContract.read.getFee([provider])) as any as bigint;

    const contract = getContract({
      address: this.address as `0x${string}`,
      abi: EXTENDED_ENTROPY_ABI,
      client: { public: publicClient, wallet: walletClient },
    });

    let hash;
    if (withCallback) {
      hash = await contract.write.requestWithCallback(
        [provider as `0x${string}`, userCommitment],
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        { value: fee } as any,
      );
    } else {
      const useBlockHash = false;
      hash = await contract.write.request(
        [provider as `0x${string}`, userCommitment, useBlockHash],
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        { value: fee } as any,
      );
    }

    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    return receipt;
  }

  async revealRandomness(
    userRevelation: string,
    providerRevelation: string,
    provider: string,
    sequenceNumber: string,
    senderPrivateKey: PrivateKey,
  ) {
    const walletClient = this.chain.getWalletClient(senderPrivateKey);
    const contract = getContract({
      address: this.address as `0x${string}`,
      abi: EXTENDED_ENTROPY_ABI,
      client: { public: this.chain.getPublicClient(), wallet: walletClient },
    });

    const hash = await contract.write.reveal(
      [
        provider as `0x${string}`,
        BigInt(sequenceNumber),
        userRevelation as `0x${string}`,
        providerRevelation as `0x${string}`,
      ],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      {} as any,
    );

    const publicClient = this.chain.getPublicClient();
    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    return receipt;
  }

  async getAccruedPythFees(): Promise<string> {
    const contract = this.getContract();
    return (await contract.read.getAccruedPythFees([])) as Promise<string>;
  }
}

export class EvmExecutorContract extends Storable {
  static type = "EvmExecutorContract";

  constructor(
    public chain: EvmChain,
    public address: string,
  ) {
    super();
  }

  getId(): string {
    return `${this.chain.getId()}_${this.address}`;
  }

  getType(): string {
    return EvmExecutorContract.type;
  }

  toJson() {
    return {
      chain: this.chain.getId(),
      address: this.address,
      type: EvmExecutorContract.type,
    };
  }

  async getWormholeContract(): Promise<EvmWormholeContract> {
    const client = this.chain.getPublicClient();
    let address = await client.getStorageAt({
      address: this.address as `0x${string}`,
      slot: toHex(251),
    });
    address = "0x" + address!.slice(26);
    return new EvmWormholeContract(this.chain, address);
  }

  static fromJson(
    chain: Chain,
    parsed: { type: string; address: string },
  ): EvmExecutorContract {
    if (parsed.type !== EvmExecutorContract.type)
      throw new Error("Invalid type");
    if (!(chain instanceof EvmChain))
      throw new Error(`Wrong chain type ${chain}`);
    return new EvmExecutorContract(chain, parsed.address);
  }

  getContract() {
    const client = this.chain.getPublicClient();
    return getContract({
      address: this.address as `0x${string}`,
      abi: EXECUTOR_ABI,
      client,
    });
  }

  async getLastExecutedGovernanceSequence() {
    return Number(await this.getContract().read.lastExecutedSequence([]));
  }

  async getGovernanceDataSource(): Promise<DataSource> {
    const executorContract = this.getContract();
    const ownerEmitterAddress =
      (await executorContract.read.governanceDataSourceEmitterAddress(
        [],
      )) as `0x${string}`;
    const ownerEmitterChainid =
      await executorContract.read.governanceDataSourceChainId([]);
    return {
      emitterChain: Number(ownerEmitterChainid),
      emitterAddress: ownerEmitterAddress.replace("0x", ""),
    };
  }

  /**
   * Returns the owner of the executor contract, this should always be the contract address itself
   */
  async getOwner(): Promise<string> {
    const contract = this.getContract();
    return contract.read.owner([]) as Promise<string>;
  }

  async executeGovernanceInstruction(
    senderPrivateKey: PrivateKey,
    vaa: Buffer,
  ) {
    const walletClient = this.chain.getWalletClient(senderPrivateKey);
    const contract = getContract({
      address: this.address as `0x${string}`,
      abi: EXECUTOR_ABI,
      client: { public: this.chain.getPublicClient(), wallet: walletClient },
    });

    const hash = await contract.write.execute(
      [("0x" + vaa.toString("hex")) as `0x${string}`],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      {} as any,
    );

    const publicClient = this.chain.getPublicClient();
    const receipt = await publicClient.waitForTransactionReceipt({ hash });

    return { id: hash, info: receipt };
  }
}

export class EvmPriceFeedContract extends PriceFeedContract {
  static type = "EvmPriceFeedContract";

  constructor(
    public chain: EvmChain,
    public address: string,
  ) {
    super();
  }

  static fromJson(
    chain: Chain,
    parsed: { type: string; address: string },
  ): EvmPriceFeedContract {
    if (parsed.type !== EvmPriceFeedContract.type)
      throw new Error("Invalid type");
    if (!(chain instanceof EvmChain))
      throw new Error(`Wrong chain type ${chain}`);
    return new EvmPriceFeedContract(chain, parsed.address);
  }

  getId(): string {
    return `${this.chain.getId()}_${this.address}`;
  }

  getType(): string {
    return EvmPriceFeedContract.type;
  }

  async getVersion(): Promise<string> {
    const pythContract = this.getContract();
    return pythContract.read.version([]) as Promise<string>;
  }

  getContract() {
    const client = this.chain.getPublicClient();
    return getContract({
      address: this.address as `0x${string}`,
      abi: EXTENDED_PYTH_ABI,
      client,
    });
  }

  /**
   * Returns the bytecode of the contract in hex format
   */
  async getCode(): Promise<string> {
    const client = this.chain.getPublicClient();
    const code = await client.getCode({
      address: this.address as `0x${string}`,
    });
    return code || "0x";
  }

  async getImplementationAddress(): Promise<string> {
    const client = this.chain.getPublicClient();
    const storagePosition =
      "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
    let address = await client.getStorageAt({
      address: this.address as `0x${string}`,
      slot: storagePosition as `0x${string}`,
    });
    address = "0x" + address!.slice(26);
    return address;
  }

  /**
   * Returns the keccak256 digest of the contract bytecode
   */
  async getCodeDigestWithoutAddress(): Promise<string> {
    return getCodeDigestWithoutAddress(
      this.chain.getPublicClient(),
      this.address,
    );
  }

  async getTotalFee(): Promise<TokenQty> {
    const client = this.chain.getPublicClient();
    const amount = await client.getBalance({
      address: this.address as `0x${string}`,
    });
    return {
      amount,
      denom: this.chain.getNativeToken(),
    };
  }

  async getLastExecutedGovernanceSequence() {
    const pythContract = this.getContract();
    return Number(await pythContract.read.lastExecutedGovernanceSequence([]));
  }

  async getPriceFeed(feedId: string) {
    const pythContract = this.getContract();
    const feed = ("0x" + feedId) as `0x${string}`;
    const exists = await pythContract.read.priceFeedExists([feed]);
    if (!exists) {
      return undefined;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const priceData = (await pythContract.read.getPriceUnsafe([feed])) as any;
    const [price, conf, expo, publishTime] = [
      priceData[0],
      priceData[1],
      priceData[2],
      priceData[3],
    ];

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const emaData = (await pythContract.read.getEmaPriceUnsafe([feed])) as any;
    const [emaPrice, emaConf, emaExpo, emaPublishTime] = [
      emaData[0],
      emaData[1],
      emaData[2],
      emaData[3],
    ];
    return {
      price: { price, conf, expo, publishTime },
      emaPrice: {
        price: emaPrice,
        conf: emaConf,
        expo: emaExpo,
        publishTime: emaPublishTime,
      },
    };
  }

  async getValidTimePeriod() {
    const pythContract = this.getContract();
    const result = await pythContract.read.getValidTimePeriod([]);
    return Number(result);
  }

  /**
   * Returns the wormhole contract which is being used for VAA verification
   */
  async getWormholeContract(): Promise<EvmWormholeContract> {
    const pythContract = this.getContract();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const address = (await pythContract.read.wormhole([])) as any as string;
    return new EvmWormholeContract(this.chain, address);
  }

  async getBaseUpdateFee(): Promise<{ amount: string }> {
    const pythContract = this.getContract();
    const result = (await pythContract.read.singleUpdateFeeInWei(
      [],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    )) as any as bigint;
    return { amount: result.toString() };
  }

  async getDataSources(): Promise<DataSource[]> {
    const pythContract = this.getContract();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const result = (await pythContract.read.validDataSources([])) as any[];
    return result.map(
      ({
        chainId,
        emitterAddress,
      }: {
        chainId: string;
        emitterAddress: string;
      }) => {
        return {
          emitterChain: Number(chainId),
          emitterAddress: emitterAddress.replace("0x", ""),
        };
      },
    );
  }

  async getGovernanceDataSource(): Promise<DataSource> {
    const pythContract = this.getContract();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const result = (await pythContract.read.governanceDataSource([])) as any[];
    const [chainId, emitterAddress] = result;
    return {
      emitterChain: Number(chainId),
      emitterAddress: emitterAddress.replace("0x", ""),
    };
  }

  async executeUpdatePriceFeed(senderPrivateKey: PrivateKey, vaas: Buffer[]) {
    const walletClient = this.chain.getWalletClient(senderPrivateKey);
    const publicClient = this.chain.getPublicClient();

    const priceFeedUpdateData = vaas.map(
      (vaa) => ("0x" + vaa.toString("hex")) as `0x${string}`,
    );

    const readContract = getContract({
      address: this.address as `0x${string}`,
      abi: EXTENDED_PYTH_ABI,
      client: publicClient,
    });

    const updateFee = (await readContract.read.getUpdateFee([
      priceFeedUpdateData,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ])) as any as bigint;

    const contract = getContract({
      address: this.address as `0x${string}`,
      abi: EXTENDED_PYTH_ABI,
      client: { public: publicClient, wallet: walletClient },
    });

    const hash = await contract.write.updatePriceFeeds(
      [priceFeedUpdateData],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      { value: updateFee } as any,
    );

    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    return { id: hash, info: receipt };
  }

  async executeGovernanceInstruction(
    senderPrivateKey: PrivateKey,
    vaa: Buffer,
  ) {
    const walletClient = this.chain.getWalletClient(senderPrivateKey);
    const publicClient = this.chain.getPublicClient();
    const contract = getContract({
      address: this.address as `0x${string}`,
      abi: EXTENDED_PYTH_ABI,
      client: { public: publicClient, wallet: walletClient },
    });

    const hash = await contract.write.executeGovernanceInstruction(
      [("0x" + vaa.toString("hex")) as `0x${string}`],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      {} as any,
    );

    const receipt = await publicClient.waitForTransactionReceipt({ hash });

    return { id: hash, info: receipt };
  }

  getChain(): EvmChain {
    return this.chain;
  }

  toJson() {
    return {
      chain: this.chain.getId(),
      address: this.address,
      type: EvmPriceFeedContract.type,
    };
  }
}

export const PULSE_DEFAULT_PROVIDER = {
  mainnet: "0x78357316239040e19fC823372cC179ca75e64b81",
  testnet: "0x78357316239040e19fC823372cC179ca75e64b81",
};
export const PULSE_DEFAULT_KEEPER = {
  mainnet: "0x78357316239040e19fC823372cC179ca75e64b81",
  testnet: "0x78357316239040e19fC823372cC179ca75e64b81",
};

export class EvmPulseContract extends Storable {
  static type = "EvmPulseContract";

  constructor(
    public chain: EvmChain,
    public address: string,
  ) {
    super();
  }

  getId(): string {
    return `${this.chain.getId()}_${this.address}`;
  }

  getChain(): EvmChain {
    return this.chain;
  }

  getType(): string {
    return EvmPulseContract.type;
  }

  getContract() {
    const client = this.chain.getPublicClient();
    return getContract({
      address: this.address as `0x${string}`,
      abi: PULSE_UPGRADEABLE_ABI,
      client,
    });
  }

  static fromJson(
    chain: Chain,
    parsed: { type: string; address: string },
  ): EvmPulseContract {
    if (parsed.type !== EvmPulseContract.type) throw new Error("Invalid type");
    if (!(chain instanceof EvmChain))
      throw new Error(`Wrong chain type ${chain}`);
    return new EvmPulseContract(chain, parsed.address);
  }

  toJson() {
    return {
      chain: this.chain.getId(),
      address: this.address,
      type: EvmPulseContract.type,
    };
  }

  async getOwner(): Promise<string> {
    const contract = this.getContract();
    return contract.read.owner([]) as Promise<string>;
  }

  async getExecutorContract(): Promise<EvmExecutorContract> {
    const owner = await this.getOwner();
    return new EvmExecutorContract(this.chain, owner);
  }

  async getPythFeeInWei(): Promise<string> {
    const contract = this.getContract();
    return contract.read.getPythFeeInWei([]) as Promise<string>;
  }

  async getFee(callbackGasLimit: number): Promise<string> {
    const contract = this.getContract();
    const result = (await contract.read.getFee([
      callbackGasLimit,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ])) as any as bigint;
    return result.toString();
  }

  async getAccruedFees(): Promise<string> {
    const contract = this.getContract();
    return contract.read.getAccruedFees([]) as Promise<string>;
  }

  async getRequest(sequenceNumber: number): Promise<{
    provider: string;
    publishTime: string;
    priceIds: string[];
    callbackGasLimit: string;
    requester: string;
  }> {
    const contract = this.getContract();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return contract.read.getRequest([sequenceNumber]) as any;
  }

  async getDefaultProvider(): Promise<string> {
    const contract = this.getContract();
    return contract.read.getDefaultProvider([]) as Promise<string>;
  }

  async getProviderInfo(provider: string): Promise<{
    feeInWei: string;
    accruedFeesInWei: string;
  }> {
    const contract = this.getContract();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return contract.read.getProviderInfo([provider as `0x${string}`]) as any;
  }

  async getExclusivityPeriod(): Promise<string> {
    const contract = this.getContract();
    return contract.read.getExclusivityPeriod([]) as Promise<string>;
  }

  async getFirstActiveRequests(count: number): Promise<{
    requests: Array<{
      provider: string;
      publishTime: string;
      priceIds: string[];
      callbackGasLimit: string;
      requester: string;
    }>;
    actualCount: number;
  }> {
    const contract = this.getContract();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return contract.read.getFirstActiveRequests([count]) as any;
  }

  async requestPriceUpdatesWithCallback(
    senderPrivateKey: PrivateKey,
    publishTime: number,
    priceIds: string[],
    callbackGasLimit: number,
  ) {
    const walletClient = this.chain.getWalletClient(senderPrivateKey);
    const publicClient = this.chain.getPublicClient();
    const contract = getContract({
      address: this.address as `0x${string}`,
      abi: PULSE_UPGRADEABLE_ABI,
      client: { public: publicClient, wallet: walletClient },
    });

    const fee = await this.getFee(callbackGasLimit);

    const hash = await contract.write.requestPriceUpdatesWithCallback(
      [
        publishTime,
        priceIds.map((id) => id as `0x${string}`),
        callbackGasLimit,
      ],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      { value: BigInt(fee) } as any,
    );

    const receipt = await publicClient.waitForTransactionReceipt({ hash });

    return { id: hash, info: receipt };
  }

  async executeCallback(
    senderPrivateKey: PrivateKey,
    sequenceNumber: number,
    updateData: string[],
    priceIds: string[],
  ) {
    const walletClient = this.chain.getWalletClient(senderPrivateKey);
    const publicClient = this.chain.getPublicClient();
    const contract = getContract({
      address: this.address as `0x${string}`,
      abi: PULSE_UPGRADEABLE_ABI,
      client: { public: publicClient, wallet: walletClient },
    });

    const hash = await contract.write.executeCallback(
      [
        sequenceNumber,
        updateData.map((d) => d as `0x${string}`),
        priceIds.map((id) => id as `0x${string}`),
      ],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      {} as any,
    );

    const receipt = await publicClient.waitForTransactionReceipt({ hash });

    return { id: hash, info: receipt };
  }

  // Admin functions
  async generateSetFeeManagerPayload(manager: string): Promise<Buffer> {
    const data = encodeFunctionData({
      abi: PULSE_UPGRADEABLE_ABI,
      functionName: "setFeeManager",
      args: [manager],
    });
    return this.chain.generateExecutorPayload(
      await this.getOwner(),
      this.address,
      data,
    );
  }

  async generateSetDefaultProviderPayload(provider: string): Promise<Buffer> {
    const data = encodeFunctionData({
      abi: PULSE_UPGRADEABLE_ABI,
      functionName: "setDefaultProvider",
      args: [provider],
    });
    return this.chain.generateExecutorPayload(
      await this.getOwner(),
      this.address,
      data,
    );
  }

  async generateSetExclusivityPeriodPayload(
    periodSeconds: number,
  ): Promise<Buffer> {
    const data = encodeFunctionData({
      abi: PULSE_UPGRADEABLE_ABI,
      functionName: "setExclusivityPeriod",
      args: [periodSeconds],
    });
    return this.chain.generateExecutorPayload(
      await this.getOwner(),
      this.address,
      data,
    );
  }
}

export class EvmLazerContract extends Storable {
  static type = "EvmLazerContract";

  constructor(
    public chain: EvmChain,
    public address: string,
  ) {
    super();
  }

  getId(): string {
    return `${this.chain.getId()}_${this.address}`;
  }

  getType(): string {
    return EvmLazerContract.type;
  }

  toJson() {
    return {
      chain: this.chain.getId(),
      address: this.address,
      type: EvmLazerContract.type,
    };
  }

  static fromJson(
    chain: Chain,
    parsed: { type: string; address: string },
  ): EvmLazerContract {
    if (parsed.type !== EvmLazerContract.type) {
      throw new Error("Invalid type");
    }
    return new EvmLazerContract(chain as EvmChain, parsed.address);
  }

  getContract() {
    const client = this.chain.getPublicClient();
    return getContract({
      address: this.address as `0x${string}`,
      abi: LAZER_ABI,
      client,
    });
  }

  async getVersion(): Promise<string> {
    const contract = this.getContract();
    return (await contract.read.version([])) as Promise<string>;
  }

  async getOwner(): Promise<string> {
    const contract = this.getContract();
    return contract.read.owner([]) as Promise<string>;
  }

  async getTrustedSigner(): Promise<{
    signer: string;
    expiresAt: string;
  }> {
    const contract = this.getContract();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return contract.read.trustedSigner([]) as any;
  }

  async generateUpdateTrustedSignerPayload(
    trustedSigner: string,
    expiresAt: number,
  ): Promise<Buffer> {
    const executorAddress = await this.getOwner();
    const data = encodeFunctionData({
      abi: EXECUTOR_ABI,
      functionName: "updateTrustedSigner",
      args: [trustedSigner, expiresAt],
    });
    return this.chain.generateExecutorPayload(
      executorAddress,
      this.address,
      data,
    );
  }

  /**
   * Updates the trusted signer for the PythLazer contract
   * @param trustedSigner The address of the trusted signer
   * @param expiresAt The expiration timestamp for the signer
   * @param privateKey The private key to sign the transaction
   * @note The privateKey should be the owner of the Lazer contract. It's not possible to run this function if the executor contract is the owner.
   */
  async updateTrustedSigner(
    trustedSigner: string,
    expiresAt: number,
    privateKey: PrivateKey,
  ): Promise<void> {
    const walletClient = this.chain.getWalletClient(privateKey);
    const publicClient = this.chain.getPublicClient();

    const contract = getContract({
      address: this.address as `0x${string}`,
      abi: LAZER_ABI,
      client: { public: publicClient, wallet: walletClient },
    });

    const gasEstimate = await publicClient.estimateContractGas({
      address: this.address as `0x${string}`,
      abi: LAZER_ABI,
      functionName: "updateTrustedSigner",
      args: [trustedSigner as `0x${string}`, expiresAt],
      account: walletClient.account,
    });

    const hash = await contract.write.updateTrustedSigner(
      [trustedSigner as `0x${string}`, expiresAt],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      { gas: BigInt(Math.floor(Number(gasEstimate) * 1.2)) } as any,
    );

    const receipt = await publicClient.waitForTransactionReceipt({ hash });

    console.log(
      `âœ… Updated trusted signer ${trustedSigner} with expiration ${expiresAt}`,
    );
    console.log(`Transaction hash: ${receipt.transactionHash}`);
  }
}
