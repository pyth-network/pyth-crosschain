"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
const yargs_1 = __importDefault(require("yargs"));
const helpers_1 = require("yargs/helpers");
const index_1 = require("../index");
const accounts_1 = require("viem/accounts");
const viem_1 = require("viem");
const const_1 = require("../const");
const DAY_IN_SECONDS = 60 * 60 * 24;
class SimpleSearcherEvm {
  endpoint;
  chainId;
  privateKey;
  apiKey;
  client;
  constructor(endpoint, chainId, privateKey, apiKey) {
    this.endpoint = endpoint;
    this.chainId = chainId;
    this.privateKey = privateKey;
    this.apiKey = apiKey;
    this.client = new index_1.Client(
      {
        baseUrl: endpoint,
        apiKey,
      },
      undefined,
      this.opportunityHandler.bind(this),
      this.bidStatusHandler.bind(this),
    );
  }
  async bidStatusHandler(_bidStatus) {
    const bidStatus = _bidStatus;
    let resultDetails = "";
    if (bidStatus.type == "submitted" || bidStatus.type == "won") {
      resultDetails = `, transaction ${bidStatus.result}, index ${bidStatus.index} of multicall`;
    } else if (bidStatus.type == "lost") {
      if (bidStatus.result) {
        resultDetails = `, transaction ${bidStatus.result}`;
      }
      if (bidStatus.index) {
        resultDetails += `, index ${bidStatus.index} of multicall`;
      }
    }
    console.log(
      `Bid status for bid ${bidStatus.id}: ${bidStatus.type}${resultDetails}`,
    );
  }
  async opportunityHandler(opportunity) {
    if (!("targetContract" in opportunity))
      throw new Error("Not a valid EVM opportunity");
    const bidAmount = BigInt(argv.bid);
    // Bid info should be generated by evaluating the opportunity
    // here for simplicity we are using a constant bid and 24 hours of validity
    // TODO: generate nonce more intelligently, to reduce gas costs
    const nonce = BigInt(Math.floor(Math.random() * 2 ** 50));
    const bidParams = {
      amount: bidAmount,
      nonce: nonce,
      deadline: BigInt(Math.round(Date.now() / 1000 + DAY_IN_SECONDS)),
    };
    const bid = await this.client.signBid(
      opportunity,
      bidParams,
      (0, index_1.checkHex)(argv.privateKey),
    );
    try {
      const bidId = await this.client.submitBid(bid);
      console.log(
        `Successful bid. Opportunity id ${opportunity.opportunityId} Bid id ${bidId}`,
      );
    } catch (error) {
      console.error(
        `Failed to bid on opportunity ${opportunity.opportunityId}: ${error}`,
      );
    }
  }
  async start() {
    try {
      await this.client.subscribeChains([argv.chainId]);
      console.log(
        `Subscribed to chain ${argv.chainId}. Waiting for opportunities...`,
      );
    } catch (error) {
      console.error(error);
      this.client.websocket?.close();
    }
  }
}
const argv = (0, yargs_1.default)((0, helpers_1.hideBin)(process.argv))
  .option("endpoint", {
    description:
      "Express relay endpoint. e.g: https://per-staging.dourolabs.app/",
    type: "string",
    demandOption: true,
  })
  .option("chain-id", {
    description: "Chain id to fetch opportunities for. e.g: sepolia",
    type: "string",
    demandOption: true,
  })
  .option("bid", {
    description: "Bid amount in wei",
    type: "string",
    default: "10000000000000000",
  })
  .option("private-key", {
    description:
      "Private key to sign the bid with in hex format with 0x prefix. e.g: 0xdeadbeef...",
    type: "string",
    demandOption: true,
  })
  .option("api-key", {
    description:
      "The API key of the searcher to authenticate with the server for fetching and submitting bids",
    type: "string",
    demandOption: false,
  })
  .help()
  .alias("help", "h")
  .parseSync();
async function run() {
  if ((0, viem_1.isHex)(argv.privateKey)) {
    const account = (0, accounts_1.privateKeyToAccount)(argv.privateKey);
    console.log(`Using account: ${account.address}`);
  } else {
    throw new Error(`Invalid private key: ${argv.privateKey}`);
  }
  const searcher = new SimpleSearcherEvm(
    argv.endpoint,
    argv.chainId,
    argv.privateKey,
    argv.apiKey,
  );
  if (const_1.OPPORTUNITY_ADAPTER_CONFIGS[argv.chainId] === undefined) {
    throw new Error(
      `Opportunity adapter config not found for chain ${argv.chainId}`,
    );
  }
  await searcher.start();
}
run();
