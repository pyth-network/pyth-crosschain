import yargs from "yargs";
import { hideBin } from "yargs/helpers";
import { checkHex, Client } from "../index";
import { privateKeyToAccount } from "viem/accounts";
import { BidStatusUpdate, Opportunity } from "../types";
import {
  OPPORTUNITY_ADAPTER_CONFIGS,
  SVM_CONSTANTS,
  SVM_CHAIN_IDS,
} from "../const";

import * as anchor from "@coral-xyz/anchor";
import { Program, AnchorProvider } from "@coral-xyz/anchor";
import { Keypair, PublicKey, Connection } from "@solana/web3.js";
import dummyIdl from "./idl_dummy.json";
import { Dummy } from "./idlTypesDummy";

const DAY_IN_SECONDS = 60 * 60 * 24;
const DUMMY_PIDS: Record<string, PublicKey> = {
  solana: new PublicKey("HYCgALnu6CM2gkQVopa1HGaNf8Vzbs9bomWRiKP267P3"),
};

class SimpleSearcher {
  private client: Client;
  private privateKeyEvm?: string;
  private privateKeySvm?: string;
  constructor(
    public endpoint: string,
    public chainId: string,
    public privateKey: string,
    public apiKey?: string
  ) {
    this.client = new Client(
      {
        baseUrl: endpoint,
        apiKey,
        svmEndpoints: {
          [chainId]: argv.svmEndpoint!,
        },
      },
      undefined,
      this.opportunityHandler.bind(this),
      this.bidStatusHandler.bind(this)
    );

    if (SVM_CHAIN_IDS.includes(chainId)) {
      this.privateKeySvm = privateKey;
    } else {
      this.privateKeyEvm = privateKey;
    }
  }

  async bidStatusHandler(bidStatus: BidStatusUpdate) {
    let resultDetails = "";
    if (bidStatus.type == "submitted" || bidStatus.type == "won") {
      resultDetails = `, transaction ${bidStatus.result}, index ${bidStatus.index} of multicall`;
    } else if (bidStatus.type == "lost") {
      if (bidStatus.result) {
        resultDetails = `, transaction ${bidStatus.result}`;
      }
      if (bidStatus.index) {
        resultDetails += `, index ${bidStatus.index} of multicall`;
      }
    }
    console.log(
      `Bid status for bid ${bidStatus.id}: ${bidStatus.type.replaceAll(
        "_",
        " "
      )}${resultDetails}`
    );
  }

  async opportunityHandler(opportunity: Opportunity) {
    const bidAmount = BigInt(argv.bid);
    // Bid info should be generated by evaluating the opportunity
    // here for simplicity we are using a constant bid and 24 hours of validity
    // TODO: generate nonce more intelligently, to reduce gas costs
    const nonce = BigInt(Math.floor(Math.random() * 2 ** 50));
    const bidParams = {
      amount: bidAmount,
      nonce: nonce,
      deadline: BigInt(Math.round(Date.now() / 1000 + DAY_IN_SECONDS)),
    };
    if (this.privateKeyEvm === undefined) {
      throw new Error("EVM private key not provided");
    }
    const bid = await this.client.signBid(
      opportunity,
      bidParams,
      checkHex(this.privateKeyEvm)
    );
    try {
      const bidId = await this.client.submitBid(bid);
      console.log(
        `Successful bid. Opportunity id ${opportunity.opportunityId} Bid id ${bidId}`
      );
    } catch (error) {
      console.error(
        `Failed to bid on opportunity ${opportunity.opportunityId}: ${error}`
      );
    }
  }

  async svmDummyBid() {
    if (this.privateKeySvm === undefined) {
      throw new Error("SVM private key not provided");
    }
    const secretKey = anchor.utils.bytes.bs58.decode(this.privateKeySvm);
    const searcher = Keypair.fromSecretKey(secretKey);

    if (argv.svmEndpoint === undefined) {
      throw new Error("SVM endpoint not provided");
    }
    const connection = new Connection(argv.svmEndpoint, "confirmed");
    const provider = new AnchorProvider(
      connection,
      new anchor.Wallet(searcher),
      {}
    );
    const dummy = new Program<Dummy>(dummyIdl as Dummy, provider);

    const permission = PublicKey.default;
    const bidAmount = new anchor.BN(argv.bid);

    const svmConstants = SVM_CONSTANTS[argv.chainId];
    const dummyPid = DUMMY_PIDS[argv.chainId];

    const ixDummy = await dummy.methods
      .doNothing()
      .accountsPartial({
        payer: searcher.publicKey,
        expressRelay: svmConstants.expressRelayProgram,
        sysvarInstructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
        permission,
        protocol: dummyPid,
      })
      .instruction();
    ixDummy.programId = dummyPid;

    const txRaw = new anchor.web3.Transaction().add(ixDummy);

    const txPermissioned = await this.client.constructPermissionedTxFromSvmTx(
      txRaw,
      dummy.programId,
      permission,
      bidAmount,
      new anchor.BN(Math.round(Date.now() / 1000 + DAY_IN_SECONDS)),
      secretKey,
      argv.chainId
    );

    try {
      const bidId = await this.client.signAndSubmitSvmBid(
        txPermissioned,
        permission,
        bidAmount,
        [secretKey],
        argv.chainId
      );
      console.log(`Successful bid. Bid id ${bidId}`);
    } catch (error) {
      console.error(`Failed to bid: ${error}`);
    }
  }

  async start() {
    if (SVM_CHAIN_IDS.includes(argv.chainId)) {
      for (;;) {
        await this.svmDummyBid();
        await new Promise((resolve) => setTimeout(resolve, 2000));
      }
    } else {
      try {
        await this.client.subscribeChains([argv.chainId]);
        console.log(
          `Subscribed to chain ${argv.chainId}. Waiting for opportunities...`
        );
      } catch (error) {
        console.error(error);
        this.client.websocket?.close();
      }
    }
  }
}

const argv = yargs(hideBin(process.argv))
  .option("endpoint", {
    description:
      "Express relay endpoint. e.g: https://per-staging.dourolabs.app/",
    type: "string",
    demandOption: true,
  })
  .option("chain-id", {
    description: "Chain id to fetch opportunities for. e.g: sepolia",
    type: "string",
    demandOption: true,
  })
  .option("bid", {
    description: "Bid amount in wei/lamports",
    type: "string",
    default: "10000000000000000",
  })
  .option("private-key", {
    description:
      "Private key to sign the bid with. In hex format with 0x prefix (e.g: 0xdeadbeef...) for EVM, 64-byte base58 format for SVM",
    type: "string",
    demandOption: true,
  })
  .option("api-key", {
    description:
      "The API key of the searcher to authenticate with the server for fetching and submitting bids",
    type: "string",
    demandOption: false,
  })
  .option("svm-endpoint", {
    description: "SVM RPC endpoint",
    type: "string",
    demandOption: false,
  })
  .help()
  .alias("help", "h")
  .parseSync();
async function run() {
  if (SVM_CHAIN_IDS.includes(argv.chainId)) {
    if (argv.svmEndpoint === undefined) {
      throw new Error("SVM endpoint not provided");
    }
    if (SVM_CONSTANTS[argv.chainId] === undefined) {
      throw new Error(`SVM constants not found for chain ${argv.chainId}`);
    }
    const searcherSvm = Keypair.fromSecretKey(
      anchor.utils.bytes.bs58.decode(argv.privateKey)
    );
    console.log(`Using searcher pubkey: ${searcherSvm.publicKey.toBase58()}`);
  } else {
    if (OPPORTUNITY_ADAPTER_CONFIGS[argv.chainId] === undefined) {
      throw new Error(
        `Opportunity adapter config not found for chain ${argv.chainId}`
      );
    }
    const account = privateKeyToAccount(checkHex(argv.privateKey));
    console.log(`Using account: ${account.address}`);
  }

  const simpleSearcher = new SimpleSearcher(
    argv.endpoint,
    argv.chainId,
    argv.privateKey,
    argv.apiKey
  );
  await simpleSearcher.start();
}

run();
