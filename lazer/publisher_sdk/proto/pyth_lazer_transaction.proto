syntax = "proto3";
package pyth_lazer_transaction;

import "publisher_update.proto";
import "governance_instruction.proto";

// if any fields marked as [required] are missing, transaction will be rejected
// if signature does not match payload bytes, transaction will be rejected

// Signed transaction for lazer
// Payload should be created on the publisher side and encoded as bytes.
// Resulting bytes should then be signed with the signature scheme specified.
// The signed lazer transaction is encoded as bytes and sent to Pyth Lazer Relayer.
message SignedLazerTransaction {
    // [required] signature with public key
    optional SignatureData signature_data = 1;

    // [required] lazer transaction encoded as bytes through protobuf
    optional bytes payload = 2;
}

// Signature for encoded payload along with the relevant public keys to verify against it
// Public key should successfully verify payload
// Pyth Lazer will maintain a list of valid public keys
// Passed public key should be present in publisher's list of valid keys
message SignatureData {
    // [required] type of signature, which determines included data needed for verifying
    oneof data {
        Ed25519SignatureData ed25519 = 1;
    };
}

// ED25519 style signature. Should include a single signature and a single public key
// Signature will be verified using public key after determining public key is valid
message Ed25519SignatureData {
    // [required] 64 byte signature
    optional bytes signature = 1;

    // [required] 32 byte public key
    optional bytes public_key = 2;
}

// Transaction contianing one of the valid Lazer Transactions
message LazerTransaction {
    // [required] valid transaction types supported by pyth lazer
    oneof payload {
        // Expected transaction sent by Publishers
        // May contain many individual updates to various feeds
        PublisherUpdate publisher_update = 1;
        // Sent by governance.
        GovernanceInstruction governance_instruction = 2;
    }
}
