name: Update llms.txt

on:
  pull_request:
    branches:
      - main
    paths:
      - "apps/developer-hub/content/docs/**"
    types: [opened, synchronize]

# Cancel in-progress runs for the same PR
concurrency:
  group: llms-txt-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash # -eo pipefail catch-all

jobs:
  update-llms-txt:
    # Only run if PR is from the same repo (not forks) and targets main
    if: github.event.pull_request.base.ref == 'main'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout PR branch
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # pin@v4.2.2
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get changed files and detect affected products
        id: changed-files
        run: |
          # Get list of changed doc files
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD -- 'apps/developer-hub/content/docs/**/*.mdx' | head -20)
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Count changes - handle empty case explicitly to avoid integer comparison issues
          if [ -z "$CHANGED_FILES" ]; then
            FILE_COUNT=0
          else
            FILE_COUNT=$(echo "$CHANGED_FILES" | wc -l | tr -d ' ')
          fi
          echo "file_count=$FILE_COUNT" >> $GITHUB_OUTPUT

          # Check for significant changes
          SIGNIFICANT="false"

          if [ -n "$CHANGED_FILES" ] && echo "$CHANGED_FILES" | grep -qE "(index|getting-started|contract-addresses)"; then
            SIGNIFICANT="true"
          fi

          # New files added?
          NEW_FILES=$(git diff --name-only --diff-filter=A origin/${{ github.base_ref }}...HEAD -- 'apps/developer-hub/content/docs/**/*.mdx')
          if [ -n "$NEW_FILES" ]; then
            SIGNIFICANT="true"
          fi

          # Many files changed?
          if [ "$FILE_COUNT" -gt 5 ]; then
            SIGNIFICANT="true"
          fi

          echo "significant=$SIGNIFICANT" >> $GITHUB_OUTPUT

          # Determine which product route files are affected by the doc changes
          AFFECTED=""

          if echo "$CHANGED_FILES" | grep -q "content/docs/price-feeds/core/"; then
            AFFECTED="$AFFECTED llms-price-feeds-core.txt llms-price-feeds.txt"
          fi

          if echo "$CHANGED_FILES" | grep -q "content/docs/price-feeds/pro/"; then
            AFFECTED="$AFFECTED llms-price-feeds-pro.txt llms-price-feeds.txt"
          fi

          # Top-level price-feeds pages (not under core/ or pro/)
          if echo "$CHANGED_FILES" | grep "content/docs/price-feeds/" | grep -qvE "content/docs/price-feeds/(core|pro)/"; then
            AFFECTED="$AFFECTED llms-price-feeds.txt"
          fi

          if echo "$CHANGED_FILES" | grep -q "content/docs/entropy/"; then
            AFFECTED="$AFFECTED llms-entropy.txt"
          fi

          if echo "$CHANGED_FILES" | grep -q "content/docs/api-reference/pyth-core/"; then
            AFFECTED="$AFFECTED llms-price-feeds-core.txt llms-price-feeds.txt"
          fi

          if echo "$CHANGED_FILES" | grep -q "content/docs/api-reference/entropy/"; then
            AFFECTED="$AFFECTED llms-entropy.txt"
          fi

          # Deduplicate
          AFFECTED=$(echo "$AFFECTED" | tr ' ' '\n' | grep -v '^$' | sort -u | tr '\n' ' ' | xargs)
          echo "affected_products=$AFFECTED" >> $GITHUB_OUTPUT

          # Check for new top-level doc directories that don't map to existing products
          NEW_PRODUCT="false"
          if [ -n "$NEW_FILES" ]; then
            NEW_DIRS=$(echo "$NEW_FILES" \
              | sed 's|apps/developer-hub/content/docs/||' \
              | cut -d'/' -f1 \
              | sort -u)
            KNOWN_DIRS="price-feeds entropy api-reference"
            for dir in $NEW_DIRS; do
              if ! echo "$KNOWN_DIRS" | grep -qw "$dir"; then
                NEW_PRODUCT="true"
                break
              fi
            done
          fi
          echo "new_product=$NEW_PRODUCT" >> $GITHUB_OUTPUT

          echo "Significant: $SIGNIFICANT | Affected: $AFFECTED | New product: $NEW_PRODUCT"

      - name: Skip if no significant changes
        if: steps.changed-files.outputs.significant != 'true'
        run: |
          echo "No significant documentation changes detected. Skipping."

      - name: Read static headers from affected product files
        if: steps.changed-files.outputs.significant == 'true' && steps.changed-files.outputs.affected_products != ''
        id: headers
        run: |
          ROUTE_DIR="apps/developer-hub/src/app"
          AFFECTED="${{ steps.changed-files.outputs.affected_products }}"

          # Build a JSON object mapping product filename -> current STATIC_HEADER content
          HEADERS_JSON="{}"

          for product in $AFFECTED; do
            ROUTE_FILE="$ROUTE_DIR/$product/route.ts"
            if [ -f "$ROUTE_FILE" ]; then
              # Extract STATIC_HEADER content (between opening backtick and closing `; line)
              sed -n '/const STATIC_HEADER = `/,/^`;/{/const STATIC_HEADER = `/d;/^`;/d;p}' "$ROUTE_FILE" > "/tmp/header-${product}.txt"
              HEADERS_JSON=$(jq --arg key "$product" --rawfile val "/tmp/header-${product}.txt" '. + {($key): $val}' <<< "$HEADERS_JSON")
            fi
          done

          echo "$HEADERS_JSON" > /tmp/current-headers.json
          echo "Extracted headers for: $AFFECTED"

      - name: Gather context
        if: steps.changed-files.outputs.significant == 'true' && steps.changed-files.outputs.affected_products != ''
        id: context
        run: |
          # Save files list to temp file to avoid shell expansion issues
          cat << 'FILESEOF' > /tmp/changed_files.txt
          ${{ steps.changed-files.outputs.files }}
          FILESEOF

          # Get summaries of changed files
          CHANGES=""
          while IFS= read -r file; do
            # Skip empty lines
            [ -z "$file" ] && continue
            if [ -f "$file" ]; then
              # Extract title and description from frontmatter
              TITLE=$(grep -m1 "^title:" "$file" | sed 's/title: //' | tr -d '"' || echo "")
              DESC=$(grep -m1 "^description:" "$file" | sed 's/description: //' | tr -d '"' || echo "")
              CHANGES="$CHANGES
          - $file
            Title: $TITLE
            Description: $DESC"
            fi
          done < /tmp/changed_files.txt

          echo "changes<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Review static headers with GPT-4o
        if: steps.changed-files.outputs.significant == 'true' && steps.changed-files.outputs.affected_products != ''
        env:
          OPENAI_API_KEY: ${{ secrets.PYTH_NETWORK_PYTH_CROSSCHAIN_OPENAI_API_KEY }}
        run: |
          # Write system prompt to file (avoids shell quoting issues)
          cat > /tmp/system-msg.txt << 'SYSMSG'
          You review documentation changes and determine if product-specific llms.txt static headers need updating.

          Architecture: Each product has a route file with a STATIC_HEADER constant (quick-start code, key IDs, contract addresses, API endpoints, SDKs) plus dynamically generated detailed docs from MDX pages. The dynamic content auto-updates at build time â€” you are ONLY reviewing the static headers.

          Be VERY CONSERVATIVE. Most changes do NOT require header updates. Only update for:
          - New or changed contract addresses
          - New or changed API endpoints or base URLs
          - New or changed SDK package names
          - Major restructuring of quick-start code examples
          - New key features that should be highlighted in the header

          Do NOT update for: typos, expanded explanations, new tutorial pages, minor doc fixes, clarifications.

          Return a JSON object where each key is a product filename and the value is either the string "NO_UPDATE_NEEDED" or the complete updated header content.

          CRITICAL FORMATTING RULES for updated headers:
          - The content is placed inside a JavaScript template literal (backtick string)
          - You MUST escape ALL backticks as \` (backslash backtick)
          - Code blocks must use \`\`\` instead of raw backticks
          - Preserve the exact structure of headers you don't change
          - Make MINIMAL targeted edits â€” do not rewrite unaffected sections
          SYSMSG

          # Write user message to file
          CURRENT_HEADERS=$(cat /tmp/current-headers.json)
          cat > /tmp/user-msg.txt << USRMSG
          Current static headers for affected product files:

          $CURRENT_HEADERS

          Documentation changes in this PR:
          ${{ steps.context.outputs.changes }}

          For each product file listed above, determine if its static header needs updating. Return ONLY valid JSON.
          USRMSG

          # Assemble JSON request using jq with --rawfile to avoid shell quoting issues
          jq -n \
            --rawfile sys_msg /tmp/system-msg.txt \
            --rawfile usr_msg /tmp/user-msg.txt \
            '{
              model: "gpt-4o",
              max_tokens: 8192,
              response_format: { type: "json_object" },
              messages: [
                { role: "system", content: $sys_msg },
                { role: "user", content: $usr_msg }
              ]
            }' > /tmp/request.json

          # Call OpenAI API
          RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d @/tmp/request.json)

          # Extract response content
          RESULT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // "ERROR"')

          if [ "$RESULT" = "ERROR" ]; then
            echo "Error calling OpenAI API"
            echo "$RESPONSE"
            exit 1
          fi

          echo "$RESULT" > /tmp/update-decisions.json

          # Check if any updates are needed
          ANY_UPDATES=$(echo "$RESULT" | jq -r 'to_entries[] | select(.value != "NO_UPDATE_NEEDED") | .key' | head -1)
          if [ -z "$ANY_UPDATES" ]; then
            echo "no_update=true" >> $GITHUB_ENV
            echo "No header updates needed"
          else
            UPDATED_LIST=$(echo "$RESULT" | jq -r 'to_entries[] | select(.value != "NO_UPDATE_NEEDED") | .key' | tr '\n' ', ' | sed 's/,$//')
            echo "no_update=false" >> $GITHUB_ENV
            echo "updated_products=$UPDATED_LIST" >> $GITHUB_ENV
            echo "Updates needed for: $UPDATED_LIST"
          fi

      - name: Update product route files
        if: steps.changed-files.outputs.significant == 'true' && steps.changed-files.outputs.affected_products != '' && env.no_update != 'true'
        run: |
          ROUTE_DIR="apps/developer-hub/src/app"
          DECISIONS=$(cat /tmp/update-decisions.json)

          # Process each file that needs updating
          echo "$DECISIONS" | jq -r 'to_entries[] | select(.value != "NO_UPDATE_NEEDED") | .key' | while read -r product; do
            ROUTE_FILE="$ROUTE_DIR/$product/route.ts"

            if [ ! -f "$ROUTE_FILE" ]; then
              echo "Warning: $ROUTE_FILE not found, skipping"
              continue
            fi

            # Extract the new header content from the JSON decision
            echo "$DECISIONS" | jq -r --arg key "$product" '.[$key]' > /tmp/new-header.txt

            # Escape any unescaped backticks for JS template literal safety
            sed -i 's/\\`/__ESC__/g; s/`/\\`/g; s/__ESC__/\\`/g' /tmp/new-header.txt

            # Use Python to safely replace the STATIC_HEADER content in the route file
            cat > /tmp/replace-header.py << 'PYEOF'
          import sys

          file_path = sys.argv[1]
          header_path = sys.argv[2]

          with open(file_path) as f:
              source = f.read()

          with open(header_path) as f:
              new_header = f.read()

          start_marker = "const STATIC_HEADER = `"
          end_marker = "\n`;"

          start = source.index(start_marker) + len(start_marker)
          end = source.index(end_marker, start)

          result = source[:start] + new_header + source[end:]

          with open(file_path, "w") as f:
              f.write(result)

          print(f"Updated {file_path}")
          PYEOF
            python3 /tmp/replace-header.py "$ROUTE_FILE" "/tmp/new-header.txt"
          done

      - name: Format updated files
        if: steps.changed-files.outputs.significant == 'true' && steps.changed-files.outputs.affected_products != '' && env.no_update != 'true'
        run: |
          cd apps/developer-hub
          AFFECTED="${{ steps.changed-files.outputs.affected_products }}"
          for product in $AFFECTED; do
            npx biome check --write "src/app/$product/route.ts" || true
          done

      - name: Commit and push changes
        if: steps.changed-files.outputs.significant == 'true' && steps.changed-files.outputs.affected_products != '' && env.no_update != 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          AFFECTED="${{ steps.changed-files.outputs.affected_products }}"
          for product in $AFFECTED; do
            git add "apps/developer-hub/src/app/$product/route.ts"
          done

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore(developer-hub): auto-update llms.txt product headers

          Updated static headers based on documentation changes."

            git push
            echo "Changes committed and pushed"
          fi

      - name: Comment on PR
        if: steps.changed-files.outputs.significant == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const noUpdate = process.env.no_update === 'true';
            const affectedRaw = '${{ steps.changed-files.outputs.affected_products }}';
            const affectedProducts = affectedRaw.split(' ').filter(Boolean);
            const newProduct = '${{ steps.changed-files.outputs.new_product }}' === 'true';
            const updatedProducts = (process.env.updated_products || '').split(',').filter(Boolean);

            const newProductWarning = newProduct
              ? `\n> âš ï¸ **New product directory detected.** Please check if the \`llms.txt\` routing hub needs a new entry.\n`
              : '';

            let body;

            const dynamicContentNote = '\n\n> Note: New documentation pages are automatically included in the dynamic content section at build time.';

            if (affectedProducts.length === 0) {
              body = `## ðŸ¤– llms.txt Static Header Review

            Documentation changes detected, but no product-specific llms.txt files were affected.
            ${dynamicContentNote}
            ${newProductWarning}
            <details>
            <summary>Files analyzed</summary>

            \`\`\`
            ${{ steps.changed-files.outputs.files }}
            \`\`\`
            </details>`;
            } else if (noUpdate) {
              body = `## ðŸ¤– llms.txt Static Header Review

            Analyzed documentation changes â€” no updates to product static headers required.

            **Products reviewed:** ${affectedProducts.map(p => `\`${p}\``).join(', ')}
            ${dynamicContentNote}
            ${newProductWarning}
            <details>
            <summary>Files analyzed</summary>

            \`\`\`
            ${{ steps.changed-files.outputs.files }}
            \`\`\`
            </details>`;
            } else {
              body = `## ðŸ¤– llms.txt Product Headers Updated

            I've automatically updated static headers in product-specific llms.txt files based on documentation changes.

            **Products reviewed:** ${affectedProducts.map(p => `\`${p}\``).join(', ')}
            **Products updated:** ${updatedProducts.map(p => `\`${p.trim()}\``).join(', ') || 'none'}

            Please review the changes to the route files in \`apps/developer-hub/src/app/\`.
            ${dynamicContentNote}
            ${newProductWarning}
            <details>
            <summary>Files that triggered this update</summary>

            \`\`\`
            ${{ steps.changed-files.outputs.files }}
            \`\`\`
            </details>`;
            }

            // Check if we already commented
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('llms.txt')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
