---
title: REST API Reference
description: Complete reference for Pyth Pro REST API for on-demand price queries
slug: /price-feeds/pro/api/rest-api
---

import { Callout } from "fumadocs-ui/components/callout";

This page provides a complete reference for the Pyth Pro REST API, which provides on-demand price queries for scenarios where WebSocket streaming is not required.

<Callout type="info">
  For real-time price updates, use the [WebSocket API](/price-feeds/pro/api/websocket-api) instead.
  The REST API is best suited for infrequent queries or bootstrapping initial state.
</Callout>

## Base URL

```
https://pyth-lazer.dourolabs.app
```

## Authentication

All endpoints require authentication via Bearer token in the `Authorization` header:

```
Authorization: Bearer YOUR_ACCESS_TOKEN
```

<Callout type="warning">
  **Security**: Never expose your access token in frontend applications.
  Access tokens should only be used in secure backend environments.
</Callout>

---

## Endpoints

### Get Latest Price

Retrieve the latest price for one or more price feeds.

```
GET /v1/latest_price
```

#### Request

**Headers**

| Header | Required | Description |
|--------|----------|-------------|
| `Authorization` | Yes | Bearer token: `Bearer YOUR_TOKEN` |

**Query Parameters**

| Parameter | Type | Required | Description | Example |
|-----------|------|----------|-------------|---------|
| `price_feed_ids` | `string` | Yes | Comma-separated list of price feed IDs | `1,2,3` |
| `properties` | `string` | No | Comma-separated list of properties to include | `price,confidence` |
| `chains` | `string` | No | Comma-separated list of chains for signed payloads | `solana,evm` |
| `parsed` | `boolean` | No | Include human-readable parsed data (default: `true`) | `true` |
| `encoding` | `string` | No | Binary encoding format: `hex` or `base64` (default: `base64`) | `hex` |

#### Request Examples

**cURL**

```bash
curl -X GET "https://pyth-lazer.dourolabs.app/v1/latest_price?price_feed_ids=1,2&properties=price,confidence&chains=solana" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

**TypeScript**

```typescript
async function getLatestPrice(
  token: string,
  priceFeedIds: number[]
): Promise<PriceResponse> {
  const params = new URLSearchParams({
    price_feed_ids: priceFeedIds.join(","),
    properties: "price,confidence,bestBidPrice,bestAskPrice",
    chains: "solana",
    parsed: "true",
    encoding: "hex",
  });

  const response = await fetch(
    `https://pyth-lazer.dourolabs.app/v1/latest_price?${params}`,
    {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    }
  );

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${await response.text()}`);
  }

  return response.json();
}

// Usage
const prices = await getLatestPrice(process.env.ACCESS_TOKEN!, [1, 2]);
console.log(prices);
```

**Python**

```python
import requests

def get_latest_price(token: str, price_feed_ids: list[int]) -> dict:
    response = requests.get(
        "https://pyth-lazer.dourolabs.app/v1/latest_price",
        params={
            "price_feed_ids": ",".join(map(str, price_feed_ids)),
            "properties": "price,confidence",
            "chains": "solana",
            "parsed": "true",
            "encoding": "hex",
        },
        headers={
            "Authorization": f"Bearer {token}",
        },
    )
    response.raise_for_status()
    return response.json()

# Usage
import os
prices = get_latest_price(os.environ["ACCESS_TOKEN"], [1, 2])
print(prices)
```

#### Response

**Success (200 OK)**

```json
{
  "timestampUs": "1730986152400000",
  "priceFeeds": [
    {
      "priceFeedId": 1,
      "price": "11223872331053",
      "confidence": 1373488286,
      "bestBidPrice": "11222498842767",
      "bestAskPrice": "11224513591935",
      "exponent": -8,
      "publisherCount": 9,
      "marketSession": "regular"
    },
    {
      "priceFeedId": 2,
      "price": "448480908040",
      "confidence": 106965585,
      "bestBidPrice": "448475995765",
      "bestAskPrice": "448508987987",
      "exponent": -8,
      "publisherCount": 12,
      "marketSession": "regular"
    }
  ],
  "solana": {
    "encoding": "hex",
    "data": "b9011a82d239c094c52016990d6ca2b261dbb1157ad503cbd3ea0679493316150cf3457624d19ec3f6e0a0e94373ab0971e39d939beda15cc02eb3c5454eb700..."
  }
}
```

**Response Schema**

| Field | Type | Description |
|-------|------|-------------|
| `timestampUs` | `string` | Unix timestamp in microseconds |
| `priceFeeds` | `PriceFeed[]` | Array of price feed data |
| `solana` | `BinaryData` | Solana-compatible signed payload (when requested) |
| `evm` | `BinaryData` | EVM-compatible signed payload (when requested) |

**PriceFeed Object**

| Field | Type | Description |
|-------|------|-------------|
| `priceFeedId` | `number` | Unique price feed identifier |
| `price` | `string` | Price mantissa. Calculate actual: `price * 10^exponent` |
| `confidence` | `number` | Confidence interval (mantissa) |
| `bestBidPrice` | `string` | Highest bid price (mantissa) |
| `bestAskPrice` | `string` | Lowest ask price (mantissa) |
| `exponent` | `number` | Decimal exponent (typically -8) |
| `publisherCount` | `number` | Number of contributing publishers |
| `marketSession` | `string` | Trading session: `regular`, `preMarket`, `postMarket`, `overNight`, `closed` |

<Callout type="info" title="Price Calculation">
  Prices are returned as mantissa values. To get the actual price:
  ```
  actual_price = price * 10^exponent
  ```
  Example: `11223872331053 * 10^(-8) = $112,238.72`
</Callout>

#### Error Responses

| Status | Code | Description | Example Response |
|--------|------|-------------|------------------|
| `400` | `INVALID_REQUEST` | Invalid request parameters | `{"error": "INVALID_REQUEST", "message": "Invalid price_feed_ids parameter"}` |
| `401` | `UNAUTHORIZED` | Missing or invalid token | `{"error": "UNAUTHORIZED", "message": "Invalid access token"}` |
| `403` | `FORBIDDEN` | Token lacks required permissions | `{"error": "FORBIDDEN", "message": "Access denied"}` |
| `404` | `NOT_FOUND` | Price feed not found | `{"error": "NOT_FOUND", "message": "Price feed 999 not found"}` |
| `429` | `RATE_LIMITED` | Rate limit exceeded | `{"error": "RATE_LIMITED", "message": "Too many requests"}` |
| `500` | `INTERNAL_ERROR` | Server error | `{"error": "INTERNAL_ERROR", "message": "Internal server error"}` |

---

## Rate Limits

| Endpoint | Limit | Window |
|----------|-------|--------|
| `/v1/latest_price` | 100 requests | Per second |

### Rate Limit Headers

Responses include rate limit information:

```
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 1730986200
```

| Header | Description |
|--------|-------------|
| `X-RateLimit-Limit` | Maximum requests per window |
| `X-RateLimit-Remaining` | Remaining requests in current window |
| `X-RateLimit-Reset` | Unix timestamp when the window resets |

### Handling Rate Limits

```typescript
async function fetchWithRateLimit(url: string, options: RequestInit) {
  const response = await fetch(url, options);

  if (response.status === 429) {
    const resetTime = parseInt(response.headers.get("X-RateLimit-Reset") || "0");
    const waitMs = Math.max(0, resetTime * 1000 - Date.now()) + 100;

    console.log(`Rate limited. Waiting ${waitMs}ms...`);
    await new Promise(resolve => setTimeout(resolve, waitMs));

    return fetch(url, options); // Retry
  }

  return response;
}
```

---

## Error Handling

### Error Response Format

All error responses follow this structure:

```json
{
  "error": "ERROR_CODE",
  "message": "Human-readable error description"
}
```

### Retry Strategy

For transient errors (5xx, rate limits), implement exponential backoff:

```typescript
async function fetchWithRetry(
  url: string,
  options: RequestInit,
  maxRetries = 3
): Promise<Response> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);

      // Don't retry client errors (except rate limits)
      if (response.status >= 400 && response.status < 500 && response.status !== 429) {
        return response;
      }

      // Retry server errors and rate limits
      if (response.status >= 500 || response.status === 429) {
        const delay = Math.min(1000 * Math.pow(2, attempt), 10000);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }

      return response;
    } catch (error) {
      lastError = error as Error;
      const delay = Math.min(1000 * Math.pow(2, attempt), 10000);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }

  throw lastError || new Error("Max retries exceeded");
}
```

---

## When to Use REST vs WebSocket

| Use Case | Recommended API |
|----------|-----------------|
| Real-time price monitoring | WebSocket |
| High-frequency trading | WebSocket |
| Periodic price checks | REST |
| Bootstrap initial state | REST |
| Low-frequency updates | REST |
| Mobile/battery-constrained apps | REST |

---

## Related Resources

- [WebSocket API Reference](/price-feeds/pro/api/websocket-api) - Real-time streaming API
- [History API Reference](/price-feeds/pro/api/history-api) - Historical price data
- [Price Feed IDs](/price-feeds/pro/price-feed-ids) - Complete list of available feeds
- [Payload Reference](/price-feeds/pro/payload-reference) - Detailed payload structure
