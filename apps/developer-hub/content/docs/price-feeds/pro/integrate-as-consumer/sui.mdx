---
title: Consume Data on Sui
description: Consume and verify Pyth Pro price updates in Sui Move smart contracts
slug: /price-feeds/pro/integrate-as-consumer/sui
---

import { Callout } from "fumadocs-ui/components/callout";
import { Step, Steps } from "fumadocs-ui/components/steps";

This guide is intended to serve users who want to consume prices from Pyth Pro on **Sui**.

Integrating with Pyth Pro in smart contracts as a consumer is a three-step process:

1. **Subscribe** to Pyth Pro websocket to receive price updates on backend or frontend.
2. **Verify** price updates in a Programmable Transaction Block (PTB) using the Pyth Lazer Sui SDK.
3. **Consume** the verified `Update` in your smart contract.

<Steps>
  <Step>
  ### Subscribe to Pyth Pro to receive Price Updates

Pyth Pro provides a websocket endpoint to receive price updates. Pyth Pro also provides a [TypeScript SDK](https://www.npmjs.com/package/@pythnetwork/pyth-lazer-sdk) to subscribe to the websocket endpoint.

Consult [How to subscribe to prices](/price-feeds/pro/subscribe-to-prices) for a complete step-by-step guide.

When subscribing, request the `leEcdsa` format which is compatible with Sui's secp256k1 signature verification:

```typescript copy
client.subscribe({
  type: "subscribe",
  subscriptionId: 1,
  priceFeedIds: [1, 2],  // BTC/USD, ETH/USD
  properties: ["price", "bestBidPrice", "bestAskPrice", "exponent"],
  formats: ["leEcdsa"],  // Required for Sui
  channel: "fixed_rate@200ms",
  jsonBinaryEncoding: "hex",
});
```

  </Step>
  <Step>
  ### Verify price updates in a PTB

Pyth Pro provides a [Sui TypeScript SDK](https://github.com/pyth-network/pyth-crosschain/tree/main/lazer/contracts/sui/sdk/js) that handles the verification call for you.

<Callout type="warning">
  Always call `parse_and_verify_le_ecdsa_update` in a Programmable Transaction Block (PTB), not inside your smart contract.
  This allows your contract to work with any newer version of the Pyth Lazer contract, since the `Update` type remains stable.
</Callout>

Install the Sui SDK:

```bash copy
npm install @pythnetwork/pyth-lazer-sui-js
```

Use the SDK to build your transaction:

```typescript copy
import { SuiClient } from "@mysten/sui/client";
import { Transaction } from "@mysten/sui/transactions";
import { PythLazerClient } from "@pythnetwork/pyth-lazer-sdk";
import { addParseAndVerifyLeEcdsaUpdateCall } from "@pythnetwork/pyth-lazer-sui-js";

// 1. Fetch the price update from Pyth Lazer in "leEcdsa" format:
const lazer = await PythLazerClient.create({ token: lazerToken });
const latestPrice = await lazer.getLatestPrice({
  priceFeedIds: [1],
  properties: ["price", "bestBidPrice", "bestAskPrice", "exponent"],
  formats: ["leEcdsa"],
  channel: "fixed_rate@200ms",
  jsonBinaryEncoding: "hex",
});
const update = Buffer.from(latestPrice.leEcdsa?.data ?? "", "hex");

// 2. Create a new Sui transaction:
const client = new SuiClient({ url: fullnodeUrl });
const tx = new Transaction();

// 3. Add the parse and verify call:
const verifiedUpdate = await addParseAndVerifyLeEcdsaUpdateCall({
  client,
  tx,
  stateObjectId: stateId,
  update,
});

// 4. Consume `verifiedUpdate` in your own contract:
tx.moveCall({
  target: `${YOUR_PACKAGE_ID}::your_module::consume_price`,
  arguments: [verifiedUpdate],
});

// 5. Sign and execute the transaction:
const result = await client.signAndExecuteTransaction({
  transaction: tx,
  signer,
});
```

<Callout type="info">
  The `stateObjectId` is the Pyth Lazer State object on Sui. Contact the Pyth team or check the [Sui SDK README](https://github.com/pyth-network/pyth-crosschain/tree/main/lazer/contracts/sui/sdk/js) for the current mainnet and testnet state object IDs.
</Callout>

  </Step>
  <Step>
  ### Consume the verified Update in your smart contract

Your contract receives a verified `Update` object and can extract the price data it needs. Add the Pyth Lazer package as a dependency in your `Move.toml` file:

```toml copy
[dependencies]
pyth_lazer = { git = "https://github.com/pyth-network/pyth-crosschain.git", subdir = "lazer/contracts/sui", rev = "main" }
```

Import the necessary modules and write a function that accepts the `Update`:

```move copy
use pyth_lazer::update::Update;
use pyth_lazer::feed::Feed;

public fun consume_price(update: Update) {
    // Access update metadata
    let timestamp = update.timestamp();
    let channel = update.channel();

    // Get the feeds vector
    let feeds = update.feeds_ref();

    // Access the first feed
    let feed = &feeds[0];

    // Extract price data
    let feed_id = feed.feed_id();
    let price = feed.price();
    let exponent = feed.exponent();

    // Process the price data according to your application logic
    // ...
}
```

#### Accessing Price Feed Data

Each `Feed` provides accessor functions for the available price properties:

```move copy
let feed = &feeds[0];

// Get the feed ID (e.g., 1 for BTC/USD, 2 for ETH/USD)
let feed_id = feed.feed_id();

// Get the price (returns Option<Option<I64>>)
let price = feed.price();

// Get bid/ask prices (Option<Option<I64>>)
let best_bid = feed.best_bid_price();
let best_ask = feed.best_ask_price();

// Confidence interval (Option<Option<I64>>)
let confidence = feed.confidence();

// Get the exponent (typically negative, e.g., -8)
let exponent = feed.exponent();             // Option<I16>

// Publisher count
let publisher_count = feed.publisher_count(); // Option<u16>

// For derivative feeds (e.g., perpetual futures)
let funding_rate = feed.funding_rate();               // Option<Option<I64>>
let funding_timestamp = feed.funding_timestamp();     // Option<Option<u64>>
let funding_rate_interval = feed.funding_rate_interval(); // Option<Option<u64>>
```

<Callout type="warning">
  Many feed properties return `Option<Option<T>>`. The outer `Option` indicates whether the property was requested in the subscription.
  The inner `Option` indicates whether a value is available (e.g., price may be `None` if there aren't enough publishers).
  Always check both levels when accessing values.
</Callout>

#### Working with Signed Integers

Pyth prices can be negative (e.g., for certain derivative products). The SDK provides `I64` and `I16` types for signed integers:

```move copy
use pyth_lazer::i64::{Self, I64};

// Check if a price exists and extract it
let price_opt = feed.price();
if (price_opt.is_some()) {
    let inner_opt = price_opt.borrow();
    if (inner_opt.is_some()) {
        let price_i64 = inner_opt.borrow();

        // Check if negative
        let is_negative = price_i64.get_is_negative();

        // Get the magnitude (must check sign first)
        let magnitude = if (is_negative) {
            price_i64.get_magnitude_if_negative()
        } else {
            price_i64.get_magnitude_if_positive()
        };
    }
}
```

  </Step>
</Steps>

## Additional Resources

You may find these additional resources helpful for consuming prices from Pyth Pro in your Sui smart contracts.

### Price Feed IDs

Pyth Pro supports a wide range of price feeds. Consult the [Price Feed IDs](/price-feeds/pro/price-feed-ids) page for a complete list of supported price feeds.

### Examples

[pyth-lazer-example-sui](https://github.com/pyth-network/pyth-examples/tree/main/lazer/sui) is a simple example contract that parses and consumes price updates from Pyth Pro on Sui.

[pyth-lazer-example-js](https://github.com/pyth-network/pyth-examples/tree/main/lazer/js) is a simple example for subscribing to the Pyth Pro websocket.
