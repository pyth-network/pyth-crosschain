---
title: Consume Data on Sui
description: Consume and verify Pyth Pro price updates in Sui Move smart contracts
slug: /price-feeds/pro/integrate-as-consumer/sui
---

import { Callout } from "fumadocs-ui/components/callout";
import { Step, Steps } from "fumadocs-ui/components/steps";

This guide is intended to serve users who want to consume prices from Pyth Pro on **Sui**.

Integrating with Pyth Pro in smart contracts as a consumer is a three-step process:

1. **Subscribe** to Pyth Pro websocket to receive price updates on backend or frontend.
2. **Verify** price updates in a Programmable Transaction Block (PTB) using the Pyth Lazer SDK.
3. **Consume** the verified `Update` in your smart contract.

<Steps>
  <Step>
  ### Subscribe to Pyth Pro to receive Price Updates

Pyth Pro provides a websocket endpoint to receive price updates. Pyth Pro also provides a [TypeScript SDK](https://www.npmjs.com/package/@pythnetwork/pyth-lazer-sdk) to subscribe to the websocket endpoint.

Consult [How to subscribe to prices](/price-feeds/pro/subscribe-to-prices) for a complete step-by-step guide.

When subscribing, request the `leEcdsa` format which is compatible with Sui's secp256k1 signature verification:

```typescript copy
client.subscribe({
  type: "subscribe",
  subscriptionId: 1,
  priceFeedIds: [1, 2],  // BTC/USD, ETH/USD
  properties: ["price", "bestBidPrice", "bestAskPrice", "exponent"],
  formats: ["leEcdsa"],  // Required for Sui
  channel: "fixed_rate@200ms",
  jsonBinaryEncoding: "hex",
});
```

  </Step>
  <Step>
  ### Verify price updates in a PTB

Pyth Pro provides a [Sui Move SDK](https://github.com/pyth-network/pyth-crosschain/tree/main/lazer/contracts/sui), which allows consumers to verify and parse price updates on Sui.

<Callout type="warning">
  Always call `parse_and_verify_le_ecdsa_update` in a Programmable Transaction Block (PTB), not inside your smart contract.
  This allows your contract to accept any version of the `Update` type, avoiding tight coupling to a specific Pyth Lazer package version.
</Callout>

When constructing your transaction, first call the Pyth Lazer verification function, then pass the resulting `Update` to your contract:

```typescript copy
import { Transaction } from "@mysten/sui/transactions";

const tx = new Transaction();

// Step 1: Verify and parse the update in the PTB
const [update] = tx.moveCall({
  target: `${PYTH_LAZER_PACKAGE_ID}::pyth_lazer::parse_and_verify_le_ecdsa_update`,
  arguments: [
    tx.object(PYTH_LAZER_STATE_ID),  // Pyth Lazer State object
    tx.object("0x6"),                 // Sui Clock object
    tx.pure(updateBytes),             // Raw update from websocket
  ],
});

// Step 2: Pass the verified Update to your contract
tx.moveCall({
  target: `${YOUR_PACKAGE_ID}::your_module::consume_price`,
  arguments: [update],
});
```

<Callout type="info">
  The State object contains the list of trusted signers and must be passed to the verification function.
  Consult the [contract addresses](/price-feeds/pro/contract-addresses) page for the Pyth Lazer package and state object IDs on mainnet and testnet.
</Callout>

  </Step>
  <Step>
  ### Consume the verified Update in your smart contract

Your contract receives a verified `Update` object and can extract the price data it needs. Add the Pyth Lazer package as a dependency in your `Move.toml` file:

```toml copy
[dependencies]
pyth_lazer = { git = "https://github.com/pyth-network/pyth-crosschain.git", subdir = "lazer/contracts/sui", rev = "main" }
```

Import the necessary modules and write a function that accepts the `Update`:

```move copy
use pyth_lazer::update::Update;
use pyth_lazer::feed::Feed;

public fun consume_price(update: Update) {
    // Access update metadata
    let timestamp = update.timestamp();
    let channel = update.channel();

    // Get the feeds vector
    let feeds = update.feeds_ref();

    // Access the first feed using modern Move syntax
    let feed = &feeds[0];

    // Extract price data
    let feed_id = feed.feed_id();
    let price = feed.price();
    let exponent = feed.exponent();

    // Process the price data according to your application logic
    // ...
}
```

#### Accessing Price Feed Data

Each `Feed` provides accessor functions for the available price properties:

```move copy
let feed = &feeds[0];

// Get the feed ID (e.g., 1 for BTC/USD, 2 for ETH/USD)
let feed_id = feed.feed_id();

// Get the price (returns Option<Option<I64>>)
let price = feed.price();

// Get bid/ask prices
let best_bid = feed.best_bid_price();
let best_ask = feed.best_ask_price();

// Get the exponent (typically negative, e.g., -8)
let exponent = feed.exponent();

// Additional properties
let confidence = feed.confidence();
let publisher_count = feed.publisher_count();

// For derivative feeds (e.g., perpetual futures)
let funding_rate = feed.funding_rate();
let funding_timestamp = feed.funding_timestamp();
let funding_rate_interval = feed.funding_rate_interval();

// Market session status
let market_session = feed.market_session();

// EMA values
let ema_price = feed.ema_price();
let ema_confidence = feed.ema_confidence();

// Feed update timestamp
let feed_update_timestamp = feed.feed_update_timestamp();
```

<Callout type="warning">
  Many feed properties return `Option<Option<T>>`. The outer `Option` indicates whether the property was requested in the subscription.
  The inner `Option` indicates whether a value is available (e.g., price may be `None` if there aren't enough publishers).
  Always check both levels when accessing values.
</Callout>

#### Working with Signed Integers

Pyth prices can be negative (e.g., for certain derivative products). The SDK provides `I64` and `I16` types for signed integers:

```move copy
use pyth_lazer::i64::{Self, I64};
use pyth_lazer::i16::{Self, I16};

// Check if a price exists and extract it
let price_opt = feed.price();
if (price_opt.is_some()) {
    let inner_opt = price_opt.borrow();
    if (inner_opt.is_some()) {
        let price_i64 = inner_opt.borrow();
        // Use i64 module functions to work with the value
        let is_negative = price_i64.is_negative();
        let abs_value = price_i64.abs();
    }
}
```

  </Step>
</Steps>

## Additional Resources

You may find these additional resources helpful for consuming prices from Pyth Pro in your Sui smart contracts.

### Price Feed IDs

Pyth Pro supports a wide range of price feeds. Consult the [Price Feed IDs](/price-feeds/pro/price-feed-ids) page for a complete list of supported price feeds.

### Examples

[pyth-lazer-example-sui](https://github.com/pyth-network/pyth-examples/tree/main/lazer/sui) is a simple example contract that parses and consumes price updates from Pyth Pro on Sui.

[pyth-lazer-example-js](https://github.com/pyth-network/pyth-examples/tree/main/lazer/js) is a simple example for subscribing to the Pyth Pro websocket.
