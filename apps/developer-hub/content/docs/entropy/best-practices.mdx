---
title: Best Practices
description: Best practices for using Pyth Entropy in your applications
---

# Best Practices

## Limit gas usage on the callback

Keeping the callback function simple is crucial because the entropy providers limit gas usage.
This ensures gas usage is predictable and consistent, avoiding potential issues with the callback.

For example, if you want to use entropy to generate a random number for each player in a round of game,
you need to make sure that the callback function works for the maximum number of players that can be in each round.
Otherwise, the callbacks will work for some rounds with fewer players, but will fail for rounds with more players.

Multiple solutions are possible to address this problem. You can store the random number received from the callback and
either ask users to submit more transactions after the callback to continue the flow or run a background crank service
to submit the necessary transactions.

The gas limit for each chain is listed on the [contract addresses](contract-addresses) page.

## Handling callback failures

While the default entropy provider is highly reliable, in rare cases a callback might not be received. This typically happens when there's an issue with your contract's callback implementation rather than with the provider itself. The most common causes are:

1. The callback function is using more gas than the allowed limit
2. The callback function contains logic that throws an error

If you're not receiving a callback, you can manually invoke it to identify the specific issue. This allows you to:

- See if the transaction fails and why
- Check the gas usage against the chain's callback gas limit
- Debug your callback implementation

For detailed instructions on how to manually invoke and debug callbacks, refer to the [Debug Callback Failures](debug-callback-failures) guide.

## Generating random values within a specific range

You can map the random number provided by Entropy into a smaller range using the solidity [modulo operator](https://docs.soliditylang.org/en/latest/types.html#modulo).
Here is a simple example of how to map a random number provided by Entropy into a range between `minRange` and `maxRange` (inclusive).

```solidity
// Maps a random number into a range between minRange and maxRange (inclusive)
function mapRandomNumber(
    bytes32 randomNumber,
    int256 minRange,
    int256 maxRange
) internal pure returns (int256) {
    require(minRange <= maxRange, "Invalid range");

    uint256 range = uint256(maxRange - minRange + 1);
    uint256 randomUint = uint256(randomNumber);

    return minRange + int256(randomUint % range);
}
```
