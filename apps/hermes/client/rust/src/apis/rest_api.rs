/*
 * hermes
 *
 * Hermes is an agent that provides Verified Prices from the Pythnet Pyth Oracle.
 *
 * The version of the OpenAPI document: 0.8.6
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_price_feed`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPriceFeedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_vaa`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVaaError {
    Status404(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_vaa_ccip`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVaaCcipError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`latest_price_feeds`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LatestPriceFeedsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`latest_price_updates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LatestPriceUpdatesError {
    Status404(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`latest_publisher_stake_caps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LatestPublisherStakeCapsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`latest_twaps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LatestTwapsError {
    Status404(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`latest_vaas`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LatestVaasError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`price_feed_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PriceFeedIdsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`price_feeds_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PriceFeedsMetadataError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`price_stream_sse_handler`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PriceStreamSseHandlerError {
    Status404(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`timestamp_price_updates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TimestampPriceUpdatesError {
    Status404(String),
    UnknownValue(serde_json::Value),
}


/// **Deprecated: use /v2/updates/price/{publish_time} instead**  Get a price update for a price feed with a specific timestamp  Given a price feed id and timestamp, retrieve the Pyth price update closest to that timestamp.
pub async fn get_price_feed(configuration: &configuration::Configuration, id: &str, publish_time: i64, verbose: Option<bool>, binary: Option<bool>) -> Result<models::RpcPriceFeed, Error<GetPriceFeedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_publish_time = publish_time;
    let p_verbose = verbose;
    let p_binary = binary;

    let uri_str = format!("{}/api/get_price_feed", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    req_builder = req_builder.query(&[("publish_time", &p_publish_time.to_string())]);
    if let Some(ref param_value) = p_verbose {
        req_builder = req_builder.query(&[("verbose", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_binary {
        req_builder = req_builder.query(&[("binary", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RpcPriceFeed`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RpcPriceFeed`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPriceFeedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// **Deprecated: use /v2/updates/price/{publish_time} instead**  Get a VAA for a price feed with a specific timestamp  Given a price feed id and timestamp, retrieve the Pyth price update closest to that timestamp.
pub async fn get_vaa(configuration: &configuration::Configuration, id: &str, publish_time: i64) -> Result<models::GetVaaResponse, Error<GetVaaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_publish_time = publish_time;

    let uri_str = format!("{}/api/get_vaa", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    req_builder = req_builder.query(&[("publish_time", &p_publish_time.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetVaaResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetVaaResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetVaaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// **Deprecated: use /v2/updates/price/{publish_time} instead**  Get a VAA for a price feed using CCIP  This endpoint accepts a single argument which is a hex-encoded byte string of the following form: `<price feed id (32 bytes> <publish time as unix timestamp (8 bytes, big endian)>`
pub async fn get_vaa_ccip(configuration: &configuration::Configuration, data: std::path::PathBuf) -> Result<models::GetVaaCcipResponse, Error<GetVaaCcipError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_data = data;

    let uri_str = format!("{}/api/get_vaa_ccip", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("data", &p_data.display().to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetVaaCcipResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetVaaCcipResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetVaaCcipError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// **Deprecated: use /v2/updates/price/latest instead**  Get the latest price updates by price feed id.  Given a collection of price feed ids, retrieve the latest Pyth price for each price feed.
pub async fn latest_price_feeds(configuration: &configuration::Configuration, ids: Vec<String>, verbose: Option<bool>, binary: Option<bool>) -> Result<Vec<models::RpcPriceFeed>, Error<LatestPriceFeedsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ids = ids;
    let p_verbose = verbose;
    let p_binary = binary;

    let uri_str = format!("{}/api/latest_price_feeds", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_ids.into_iter().map(|p| ("ids[]".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids[]", &p_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_verbose {
        req_builder = req_builder.query(&[("verbose", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_binary {
        req_builder = req_builder.query(&[("binary", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::RpcPriceFeed&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::RpcPriceFeed&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LatestPriceFeedsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the latest price updates by price feed id.  Given a collection of price feed ids, retrieve the latest Pyth price for each price feed.
pub async fn latest_price_updates(configuration: &configuration::Configuration, ids: Vec<String>, encoding: Option<models::EncodingType>, parsed: Option<bool>, ignore_invalid_price_ids: Option<bool>) -> Result<models::PriceUpdate, Error<LatestPriceUpdatesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ids = ids;
    let p_encoding = encoding;
    let p_parsed = parsed;
    let p_ignore_invalid_price_ids = ignore_invalid_price_ids;

    let uri_str = format!("{}/v2/updates/price/latest", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_ids.into_iter().map(|p| ("ids[]".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids[]", &p_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_encoding {
        req_builder = req_builder.query(&[("encoding", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parsed {
        req_builder = req_builder.query(&[("parsed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ignore_invalid_price_ids {
        req_builder = req_builder.query(&[("ignore_invalid_price_ids", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PriceUpdate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PriceUpdate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LatestPriceUpdatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the most recent publisher stake caps update data.
pub async fn latest_publisher_stake_caps(configuration: &configuration::Configuration, encoding: Option<models::EncodingType>, parsed: Option<bool>) -> Result<models::LatestPublisherStakeCapsUpdateDataResponse, Error<LatestPublisherStakeCapsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_encoding = encoding;
    let p_parsed = parsed;

    let uri_str = format!("{}/v2/updates/publisher_stake_caps/latest", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_encoding {
        req_builder = req_builder.query(&[("encoding", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parsed {
        req_builder = req_builder.query(&[("parsed", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LatestPublisherStakeCapsUpdateDataResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LatestPublisherStakeCapsUpdateDataResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LatestPublisherStakeCapsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the latest TWAP by price feed id with a custom time window.  Given a collection of price feed ids, retrieve the latest Pyth TWAP price for each price feed.
pub async fn latest_twaps(configuration: &configuration::Configuration, window_seconds: i64, ids_left_square_bracket_right_square_bracket: Vec<String>, encoding: Option<models::EncodingType>, parsed: Option<bool>, ignore_invalid_price_ids: Option<bool>) -> Result<models::TwapsResponse, Error<LatestTwapsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_window_seconds = window_seconds;
    let p_ids_left_square_bracket_right_square_bracket = ids_left_square_bracket_right_square_bracket;
    let p_encoding = encoding;
    let p_parsed = parsed;
    let p_ignore_invalid_price_ids = ignore_invalid_price_ids;

    let uri_str = format!("{}/v2/updates/twap/{window_seconds}/latest", configuration.base_path, window_seconds=p_window_seconds);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_ids_left_square_bracket_right_square_bracket.into_iter().map(|p| ("ids[]".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids[]", &p_ids_left_square_bracket_right_square_bracket.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_encoding {
        req_builder = req_builder.query(&[("encoding", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parsed {
        req_builder = req_builder.query(&[("parsed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ignore_invalid_price_ids {
        req_builder = req_builder.query(&[("ignore_invalid_price_ids", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwapsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwapsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LatestTwapsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// **Deprecated: use /v2/updates/price/latest instead**  Get VAAs for a set of price feed ids.  Given a collection of price feed ids, retrieve the latest VAA for each. The returned VAA(s) can be submitted to the Pyth contract to update the on-chain price. If VAAs are not found for every provided price ID the call will fail.
pub async fn latest_vaas(configuration: &configuration::Configuration, ids_left_square_bracket_right_square_bracket: Vec<String>) -> Result<Vec<String>, Error<LatestVaasError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ids_left_square_bracket_right_square_bracket = ids_left_square_bracket_right_square_bracket;

    let uri_str = format!("{}/api/latest_vaas", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_ids_left_square_bracket_right_square_bracket.into_iter().map(|p| ("ids[]".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids[]", &p_ids_left_square_bracket_right_square_bracket.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LatestVaasError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// **Deprecated: use /v2/price_feeds instead**  Get the set of price feed IDs.  This endpoint fetches all of the price feed IDs for which price updates can be retrieved.
pub async fn price_feed_ids(configuration: &configuration::Configuration, ) -> Result<Vec<String>, Error<PriceFeedIdsError>> {

    let uri_str = format!("{}/api/price_feed_ids", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PriceFeedIdsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the set of price feeds.  This endpoint fetches all price feeds from the Pyth network. It can be filtered by asset type and query string.
pub async fn price_feeds_metadata(configuration: &configuration::Configuration, query: Option<&str>, asset_type: Option<models::AssetType>) -> Result<Vec<models::PriceFeedMetadata>, Error<PriceFeedsMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query = query;
    let p_asset_type = asset_type;

    let uri_str = format!("{}/v2/price_feeds", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query {
        req_builder = req_builder.query(&[("query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_asset_type {
        req_builder = req_builder.query(&[("asset_type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PriceFeedMetadata&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PriceFeedMetadata&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PriceFeedsMetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// SSE route handler for streaming price updates.  The connection will automatically close after 24 hours to prevent resource leaks. Clients should implement reconnection logic to maintain continuous price updates.
pub async fn price_stream_sse_handler(configuration: &configuration::Configuration, ids: Vec<String>, encoding: Option<models::EncodingType>, parsed: Option<bool>, allow_unordered: Option<bool>, benchmarks_only: Option<bool>, ignore_invalid_price_ids: Option<bool>) -> Result<models::PriceUpdate, Error<PriceStreamSseHandlerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ids = ids;
    let p_encoding = encoding;
    let p_parsed = parsed;
    let p_allow_unordered = allow_unordered;
    let p_benchmarks_only = benchmarks_only;
    let p_ignore_invalid_price_ids = ignore_invalid_price_ids;

    let uri_str = format!("{}/v2/updates/price/stream", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_ids.into_iter().map(|p| ("ids[]".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids[]", &p_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_encoding {
        req_builder = req_builder.query(&[("encoding", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parsed {
        req_builder = req_builder.query(&[("parsed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_allow_unordered {
        req_builder = req_builder.query(&[("allow_unordered", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_benchmarks_only {
        req_builder = req_builder.query(&[("benchmarks_only", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ignore_invalid_price_ids {
        req_builder = req_builder.query(&[("ignore_invalid_price_ids", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PriceUpdate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PriceUpdate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PriceStreamSseHandlerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the latest price updates by price feed id.  Given a collection of price feed ids, retrieve the latest Pyth price for each price feed.
pub async fn timestamp_price_updates(configuration: &configuration::Configuration, publish_time: i64, ids: Vec<String>, encoding: Option<models::EncodingType>, parsed: Option<bool>, ignore_invalid_price_ids: Option<bool>) -> Result<models::PriceUpdate, Error<TimestampPriceUpdatesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_publish_time = publish_time;
    let p_ids = ids;
    let p_encoding = encoding;
    let p_parsed = parsed;
    let p_ignore_invalid_price_ids = ignore_invalid_price_ids;

    let uri_str = format!("{}/v2/updates/price/{publish_time}", configuration.base_path, publish_time=p_publish_time);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_ids.into_iter().map(|p| ("ids[]".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids[]", &p_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_encoding {
        req_builder = req_builder.query(&[("encoding", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parsed {
        req_builder = req_builder.query(&[("parsed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ignore_invalid_price_ids {
        req_builder = req_builder.query(&[("ignore_invalid_price_ids", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PriceUpdate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PriceUpdate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TimestampPriceUpdatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}
