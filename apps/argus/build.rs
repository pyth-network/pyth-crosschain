use std::{env, path::PathBuf, fs};
use alloy_json_abi::{JsonAbi, Function};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Get project root directory from Cargo
    let manifest_dir = env::var("CARGO_MANIFEST_DIR")?;
    let project_root = PathBuf::from(manifest_dir);

    // Path to ABI file relative to project root
    let abi_path = project_root
        .join("..")
        .join("..")
        .join("target_chains")
        .join("ethereum")
        .join("contracts")
        .join("abis")
        .join("IPulse.json");

    // Tell cargo to rerun if ABI changes
    println!("cargo:rerun-if-changed={}", abi_path.display());

    // Create generated directory if it doesn't exist
    let generated_dir = project_root.join("src").join("generated");
    fs::create_dir_all(&generated_dir)?;

    // Read and parse ABI
    let abi_str = fs::read_to_string(&abi_path)?;
    let abi: JsonAbi = serde_json::from_str(&abi_str)?;

    // Generate Rust code
    let mut code = String::new();
    code.push_str("// Generated by build.rs - DO NOT EDIT\n\n");
    code.push_str("use alloy::primitives::*;\n\n");

    // Generate structs for each type
    for ty in abi.types() {
        code.push_str(&format!("#[derive(Debug, Clone)]\n"));
        code.push_str(&format!("pub struct {} {{\n", ty.name));
        for field in ty.fields() {
            code.push_str(&format!("    pub {}: {},\n", field.name, field.ty.rust_type()));
        }
        code.push_str("}\n\n");
    }

    // Generate function calls
    for func in abi.functions() {
        code.push_str(&format!("#[derive(Debug, Clone)]\n"));
        code.push_str(&format!("pub struct {}Call {{\n", func.name));
        for input in func.inputs.iter() {
            code.push_str(&format!("    pub {}: {},\n", input.name, input.ty.rust_type()));
        }
        code.push_str("}\n\n");
    }

    // Write to file
    fs::write(
        generated_dir.join("bindings.rs"),
        code
    )?;

    Ok(())
}
